# Stacktalk - DSL-Driven COBOL Policy Compliance Detection

## Project Overview
Stacktalk is a DSL-driven system for detecting policy violations in COBOL code using graph-based analysis. The system connects every piece of code to applicable DSL rules for comprehensive compliance checking.

## Architecture Principles

### 1. DSL-First Approach
- All business rules defined in YAML DSL files (`rules/*.dsl`)
- Rules are parsed into graph representation first
- Code analysis happens against graph, not raw text
- Easy for non-technical users to modify rules

### 2. Graph-Centric Design
- Graph generation happens BEFORE violation detection
- Every code element connected to applicable DSL rules
- Rich data representation enables complex analysis
- Comprehensive mapping: DSL rules â†” COBOL code â†” Violations

### 3. Modular Architecture
- Each component has single responsibility
- Independent development and testing
- Clear separation of concerns
- Extensible design for new rule types

## File Structure
```
stacktalk-demo/
â”œâ”€â”€ main.py                    # Main orchestration script
â”œâ”€â”€ src/                       # Source modules
â”‚   â”œâ”€â”€ dsl_parser.py         # DSL rule parsing & validation
â”‚   â”œâ”€â”€ cobol_generator.py    # COBOL code generation from DSL
â”‚   â”œâ”€â”€ cobol_cst_parser.py   # Tree-sitter CST-based COBOL parsing
â”‚   â”œâ”€â”€ rule_detector.py      # Rule violation detection
â”‚   â”œâ”€â”€ graph_generator.py    # Graph database operations
â”‚   â””â”€â”€ report_generator.py   # Text report generation
â”œâ”€â”€ rules/                     # Global DSL rule definitions
â”‚   â””â”€â”€ global_fraud_management.dsl
â”œâ”€â”€ programs/                  # Program-specific directories
â”‚   â”œâ”€â”€ banking/              # Example: Banking system programs
â”‚   â”‚   â”œâ”€â”€ rules/            # DSL rules (program-specific + local)
â”‚   â”‚   â””â”€â”€ *.cbl             # COBOL programs
â”‚   â”œâ”€â”€ test/                 # Test/demo programs
â”‚   â”‚   â”œâ”€â”€ rules/            # Test DSL rules
â”‚   â”‚   â””â”€â”€ *.cob             # Generated examples
â”‚   â””â”€â”€ ...                   # Other domains (insurance, healthcare, vasu, etc.)
â””â”€â”€ output/                    # Generated outputs
```

## Coding Standards
Use TDD approach : always write tests before creating new function or file

### Python Code
- Use type hints for all function parameters and return values
- Follow PEP 8 style guidelines
- Use dataclasses for structured data
- Implement proper error handling with custom exceptions
- Write comprehensive docstrings for all public methods

### DSL Files
- Use YAML format for rule definitions
- Follow consistent naming conventions (snake_case for keys)
- Include validation for all required fields
- Provide clear descriptions for business users

### Graph Operations
- Use descriptive node and edge types
- Include metadata in node properties
- Create bidirectional relationships where appropriate
- Implement graph traversal methods for analysis

## Key Components

### DSL Parser (`src/dsl_parser.py`)
- Parse YAML rule definitions from multiple sources (global, program-specific, local)
- Validate rule structure and syntax
- Convert rules to graph representation
- Support rule inheritance and composition
- **Multi-Source Rule Loading**: 
  - Global rules (`rules/*.dsl`) - Base rules for all programs
  - Program-specific rules (`programs/*/rules/*.dsl`) - Domain-specific rules
  - Local rules (`programs/*/*.dsl`) - Program-specific overrides
- **Rule Precedence**: Local > Program-specific > Global rules
- **Automatic Discovery**: Scan directory for `.dsl` files and load in precedence order
- **Consistent Structure**: All program directories follow same pattern with `rules/` subdirectory

### Graph Generator (`src/graph_generator.py`)
- Create nodes for programs, variables, procedures, rules
- Establish relationships between code and rules
- Support graph queries and analysis
- Export to JSON for visualization
- **Violation Node Creation**: Materialize violations as distinct graph nodes with rich metadata
- **Relationship Mapping**: Create `VIOLATES_RULE` and `VIOLATES_ELEMENT` relationships
- **Graph Analytics**: Enable complex violation analysis through graph traversal

### COBOL CST Parser (`src/cobol_cst_parser.py`)
- Tree-sitter-based Concrete Syntax Tree parsing
- **Complete COBOL Hierarchical Structure**: Divisions â†’ Sections â†’ Paragraphs â†’ Statement Blocks
- **Division Recognition**: IDENTIFICATION, ENVIRONMENT, DATA, PROCEDURE divisions
- **Section Parsing**: CONFIGURATION, INPUT-OUTPUT, FILE sections with proper line number handling
- **Procedure Analysis**: Sections and paragraphs within PROCEDURE DIVISION
- **Statement Block Grouping**: Logical grouping of related statements (PERFORM, IF, EVALUATE blocks)
- **Atomic Variable Parsing**: Most granular parsing with individual variables linked to statement blocks
- **Variable-to-Block Linking**: Each variable connected to specific statement blocks where used
- Hierarchical data structure parsing (01, 02, 03 level variables)
- Support for multiple COBOL dialects and enterprise patterns
- **Line Number Handling**: Proper parsing of COBOL files with line numbers (000100, 000200, etc.)

### Rule Detector (`src/rule_detector.py`)
- Analyze graph for policy violations
- Connect violations to specific code elements
- Support multiple rule types and patterns
- Provide detailed violation reports
- **Violation Materialization**: Violations are materialized as distinct nodes in the graph
- **Graph Integration**: Each violation becomes a first-class citizen with relationships to DSL rules and COBOL elements
- **Rich Metadata**: Violations include severity, source location, affected elements, and business context

### COBOL Generator (`src/cobol_generator.py`)
- Generate compliant COBOL examples from DSL using AI or templates
- Create sophisticated violation examples using OpenAI intelligence
- Support multiple COBOL dialects and business domains
- Include proper formatting, comments, and enterprise patterns
- **AI Mode**: Uses OpenAI API with business context and compliance expertise
- **Template Mode**: Falls back to template-based generation for reliability

### COBOL CST Parser (`src/cobol_cst_parser.py`)
- Tree-sitter-based Concrete Syntax Tree parsing for comprehensive COBOL analysis
- Parse COBOL divisions, sections, paragraphs, and statements
- Extract hierarchical data structures (01, 02, 03 level variables with relationships)
- Identify procedures, paragraphs, and their semantic meaning
- Support for COPY statements, file definitions, and complex business logic
- **Tree-sitter Integration**: Uses yutaro-sakamoto/tree-sitter-cobol for robust parsing
- **Semantic Analysis**: Understands business logic patterns and compliance requirements

## Development Guidelines

### 1. Graph-First Development
- Always generate graph before analysis
- Connect every code element to applicable rules
- Use graph traversal for violation detection
- Maintain graph consistency throughout
- **Violation Materialization**: Violations are materialized as distinct nodes in the graph
- **Graph Analytics**: Enable complex queries and analysis through violation relationships
- **First-Class Citizens**: Violations have the same status as rules and code elements

### 2. DSL Extensibility & Multi-Program Support
- Design DSL to be easily extensible
- Support new rule types without code changes
- Provide clear DSL documentation
- Include validation and error messages
- **Consistent Directory Structure**: All program directories follow the same pattern:
  - `programs/{domain}/rules/*.dsl` - Program-specific rules
  - `programs/{domain}/*.dsl` - Local rules (highest precedence)
  - `programs/{domain}/*.cbl` - COBOL programs
- **Rule Inheritance**: Local rules override program-specific rules, which override global rules
- **Automatic Rule Discovery**: Scan directories for `.dsl` files and load in precedence order
- **Multi-Program Analysis**: Process different programs with different rule sets in single run
- **Test/Demo Support**: Dedicated `programs/test/` directory for testing and demonstrations

### 3. CST-Based COBOL Parsing
- Use Tree-sitter with COBOL grammar for comprehensive parsing
- **Complete Hierarchical Structure**: Parse Divisions â†’ Sections â†’ Paragraphs â†’ Statement Blocks
- **Division-Level Analysis**: IDENTIFICATION, ENVIRONMENT, DATA, PROCEDURE divisions
- **Section-Level Analysis**: CONFIGURATION, INPUT-OUTPUT, FILE sections within divisions
- **Procedure-Level Analysis**: Sections and paragraphs within PROCEDURE DIVISION
- **Statement Block Analysis**: Group related statements into logical blocks (PERFORM, IF, EVALUATE)
- **Atomic Variable Parsing**: Extract individual variables and link to statement blocks
- **Variable-to-Block Relationships**: Create USED_IN_BLOCK relationships for fine-grained analysis
- Extract hierarchical data relationships and semantic meaning
- Support enterprise COBOL patterns and complex business logic
- **Line Number Support**: Handle COBOL files with line numbers (000100, 000200, etc.)
- Integrate CST parser with graph generation for complete code analysis

### 4. AI Integration
- Use OpenAI API for intelligent code generation
- Build rich business context from DSL rules and graph
- Generate sophisticated violation examples with domain expertise
- Fallback to template-based generation when AI is unavailable
- Store API key securely in `.env` file (OPENAI_KEY)

### 5. Error Handling
- Use custom exceptions for different error types
- Provide clear error messages for DSL validation
- Handle missing files and invalid syntax gracefully
- Log errors for debugging

### 6. Testing
- **TDD Approach**: Always write tests before creating new function or file
  **Unit Tests** (`tests/unit/`): DSL Parser, Graph Generator, COBOL CST Parser, COBOL Generator, Rule Detector, Report Generator
  **Integration Tests** (`tests/integration/`): Full workflow, DSL-to-Graph, COBOL-to-CST, CST-to-Graph, Graph-to-Violations, Neo4j integration

  ```bash
  python run_tests.py                    # All tests
  python run_tests.py --unit            # Unit only
  python run_tests.py --integration     # Integration only
  ```

  Expected output:
  ```
  ðŸ§ª Running Unit Tests...
  âœ… All unit tests passed!
  âœ… All integration tests passed!
  ðŸŽ‰ All tests passed! Stacktalk is ready for production.
  ```

## Business Context
- Target: Financial institutions with legacy COBOL systems
- Problem: Policy drift between documented rules and actual code
- Solution: Automated detection with graph-based analysis
- Value: Audit compliance, risk reduction, modernization support

## Performance Considerations
- Graph operations should be efficient for large codebases
- DSL parsing should be fast for interactive use
- Report generation should handle multiple violations
- Memory usage should be reasonable for enterprise deployment

## Security & Compliance
- Handle sensitive financial data appropriately
- Support audit trails and compliance reporting
- Ensure rule definitions are tamper-evident
- Provide secure access to violation reports

## Environment Configuration
- Create `.env` file with `OPENAI_KEY=your_api_key_here`
- AI mode automatically enabled when OPENAI_KEY is present
- Fallback to template mode when AI unavailable
- Support for multiple AI providers (OpenAI, Anthropic, local models)
- Neo4j integration for enterprise graph database persistence
- Tree-sitter COBOL grammar integration for comprehensive parsing
- **Multi-Program Support**: Organize COBOL programs in domain-specific directories
- **Rule Association**: Associate DSL rules with COBOL programs in same directory structure

## Neo4j Integration
- Enterprise graph database persistence for large-scale deployment
- Development: Runs via Neo4j Desktop with local credentials in `.env`
- Production: Supports Neo4j AuraDB or self-hosted Neo4j instances
- Graph operations export to Neo4j for complex analytics and visualization
- Preserve JSON export for simple deployments and testing

## Development Setup
- Install Neo4j Desktop for local development
  - Configure `.env` with Neo4j credentials:
    ```
    OPENAI_KEY=your_api_key_here
    NEO4J_URI=bolt://localhost:7687
    NEO4J_USER=neo4j
    NEO4J_PASSWORD=your_neo4j_password
    NEO4J_DATABASE=your_neo4j_database
    ```
- Graph operations automatically detect Neo4j availability
- Fallback to JSON export when Neo4j unavailable


## Future Extensions
- MCP server for API access
- CI/CD integration
- Multiple COBOL dialect support with Tree-sitter grammars
- Advanced graph analytics and visualization
- Multi-provider AI support (GPT-4, Claude, local models)
- AI-powered violation classification and remediation suggestions
- Enhanced CST parsing with semantic analysis and business logic understanding
- Integration with COBOL IDEs and development tools
- **Violation Analytics**: Advanced graph queries for violation patterns and trends
- **Violation Visualization**: Interactive violation graphs with severity-based coloring
- **Violation Remediation**: AI-powered suggestions for fixing violations
