# Stacktalk Demo - 5 Minute Quickstart

Get Stacktalk running in 5 minutes and see DSL-driven policy violations in action.

## Step 1: Setup (2 minutes)

```bash
# Create and enter project directory
mkdir stacktalk-demo
cd stacktalk-demo

# Create virtual environment
python3 -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Download all files to this directory
# (You should have: main.py, src/*.py modules, rules/*.dsl files, requirements.txt)
# 
# NOTE: This is a template - you need to create the actual implementation files
# based on the modular architecture described in this quickstart

# Install dependencies
pip install -r requirements.txt

# Optional: Setup AI-powered COBOL generation
# Create .env file with your OpenAI API key for enhanced code generation
echo "OPENAI_KEY=your_api_key_here" > .env
```

## Step 2: Verify Installation (30 seconds)

```bash
python main.py --validate
```

You should see:
```
✅ DSL validation passed! Stacktalk is ready to use.
📋 Loaded rule: NSF Banking Rule
   Variables: 4
   Requirements: 3
🧠 AI COBOL Generation: Available (OPENAI_KEY detected)
```

If you see errors, check that:
- Python 3.10+ is installed: `python --version`
- All modular files are in the correct structure
- Virtual environment is activated
- DSL rule files are present in `rules/` directory

## Step 3: Run Tests (1 minute)

```bash
# Run all tests (unit + integration)
python run_tests.py

# Run unit tests only
python run_tests.py --unit

# Run integration tests only  
python run_tests.py --integration

# Run specific test
python run_tests.py --test tests/unit/test_dsl_parser.py

# Verbose output
python run_tests.py --all --verbose
```

You should see:
```
🧪 Running Unit Tests...
✅ All unit tests passed!

🔗 Running Integration Tests...
✅ All integration tests passed!

🎉 All tests passed! Stacktalk is ready for production.
```

## Step 4: Run the Demo (1 minute)

```bash
python main.py
```

This will:
1. ✅ Parse DSL rules from `rules/*.dsl` files (global rules)
2. ✅ Generate graph from DSL rules (variables, requirements, logic)
3. ✅ **Generate AI-powered COBOL** examples using OpenAI (if API key available)
4. ✅ **Parse COBOL code with Tree-sitter CST** into graph (programs, variables, procedures, hierarchical structures)
5. ✅ Connect every code element to applicable DSL rules
6. ✅ Analyze graph for policy violations
7. ✅ Generate text report

## Step 4b: Analyze Your Own COBOL Programs (2 minutes)

```bash
# Analyze a single COBOL file with global rules
python main.py --analyze-file programs/banking/withdrawal.cbl

# Analyze all COBOL files in a directory with their associated DSL rules
python main.py --analyze-dir programs/banking/

# This automatically discovers and loads:
# 1. Global rules from rules/*.dsl
# 2. Program-specific rules from programs/banking/rules/*.dsl  
# 3. Local rules from programs/banking/*.dsl
```

## Step 5: View Results (1 minute)

### In Terminal

You'll see output like:

```
🏦 Stacktalk MVP: DSL-Driven Financial Rule Detection
============================================================
📋 Loaded rule: NSF Banking Rule (4 variables, 3 requirements)
🧠 AI COBOL Generation: Enabled (OpenAI GPT-4)
🌳 Tree-sitter CST Parser: Enabled (Comprehensive COBOL parsing)
✅ Generated AI-powered COBOL examples
✅ Generated graph from DSL rules
✅ Parsed COBOL code with Tree-sitter CST into graph
✅ Connected code elements to DSL rules
🔍 Analyzing graph for violations...
   ❌ Found 3 violations in violation.cob (AI-generated sophisticated violations)
   ✅ No violations in compliant.cob (AI-generated compliant logic)

📊 Graph Statistics: 15 nodes, 12 edges, 50% compliance
✅ Graph saved: output/graph.json
✅ Report generated: output/report.html
```

### In Browser

Open `output/report.html` to see:
- Executive summary dashboard
- Detailed violation reports with syntax highlighting
- Graph statistics and compliance metrics
- **AI-generated COBOL** with sophisticated business logic and enterprise patterns
- **Code-to-rule connections** showing which DSL rules apply to each code element
- Audit-ready formatting

## Step 6: Customize Rules (1 minute)

```bash
# Modify global NSF rule
vim rules/nsf_rule.dsl

# Create program-specific rules for banking system
mkdir -p programs/banking/rules/
vim programs/banking/rules/banking_compliance.dsl

# Create local rules for specific program
vim programs/banking/withdrawal_rules.dsl

# Run with your changes (rule precedence: local > program-specific > global)
python main.py --analyze-dir programs/banking/

# View graph data
cat output/batch_banking/graph.json

# Graph shows comprehensive connections:
# - DSL Rule nodes → Variable nodes → Requirement nodes
# - COBOL Program nodes → Variable nodes → Procedure nodes  
# - Code variables connected to DSL rule variables
# - Violations linked to specific code elements and rules
# - Rule source tracking (global/program-specific/local)
```

## What Stacktalk Detects

**NSF Banking Rule**: NSF events must be logged and fee applied
- ❌ **AI-Generated Violation**: Sophisticated fraud detection bypass, subtle audit trail gaps
- ✅ **AI-Generated Compliant**: Complete NSF handling with enterprise-grade error management

**Dual Approval Rule**: Payments >$10K require two approvers  
- ❌ **AI-Generated Violation**: Complex approval chain manipulation, timing-based exploits
- ✅ **AI-Generated Compliant**: Multi-layer authorization with comprehensive logging

## AI-Powered Code Generation

🧠 **OpenAI Integration** provides:
- **Domain Expertise**: Banking, healthcare, insurance compliance knowledge
- **Sophisticated Logic**: Real-world business scenarios and edge cases
- **Enterprise Patterns**: Proper error handling, logging, and audit trails
- **Intelligent Violations**: Subtle compliance gaps that pass basic testing
- **Context Awareness**: Understanding of regulatory requirements and best practices

## Graph Connectivity

The graph creates **comprehensive connections** between DSL rules and code:

```
DSL Rule "NSF Banking Rule"
├── Variable: NSF-LOG-FLAG
├── Variable: NSF-FEE  
├── Requirement: nsf_logging
└── Requirement: nsf_fee_application

COBOL Program "WITHDRAWAL-PROCESS"  
├── Variable: NSF-LOG-FLAG ← Connected to DSL rule variable
├── Variable: NSF-FEE ← Connected to DSL rule variable
├── Procedure: PROCESS-NSF ← Connected to DSL requirements
└── Violation: Missing logging ← Linked to specific requirement
```

**Every code element** is mapped to its corresponding DSL rule components, enabling:
- **Precise violation detection** (know exactly which rule is violated)
- **Impact analysis** (see what code changes affect which rules)
- **Compliance tracing** (track rule compliance across codebase)

## Common Issues

**Missing dependencies**: `pip install pyyaml jinja2 rich openai`

**DSL validation error**: Check YAML syntax in `rules/*.dsl`

**AI generation fails**: 
- Check `.env` file has `OPENAI_KEY=your_api_key_here`
- Verify API key is valid and has credits
- Falls back to template mode automatically

**No violations detected**: Modify DSL file to match your code patterns

## Sales Demo (10 minutes)

**Problem** (2 min): COBOL code drifts from documented policies → audit risk

**AI-Powered Demo** (3 min): 
```bash
vim rules/nsf_rule.dsl  # Modify compliance requirements
python main.py          # Watch AI generate sophisticated COBOL
```

**Results Showcase** (3 min):
- Show AI-generated enterprise-grade NSF handling vs basic templates
- Demonstrate sophisticated compliance violations that pass cursory review
- Highlight domain expertise: fraud detection, audit trails, edge cases

**Close** (2 min): "Ready for AI-powered compliance analysis? Enterprise pilot: $100K with custom DSL"

## Next Steps

**Development**: Add DSL rules → enhance graph analysis → improve reports

**Production**: Handle COPY statements → multiple COBOL dialects → Neo4j integration

**Sales**: Get 3 design partners → customize rules → generate case studies

## Directory Structure

```
stacktalk-demo/
├── main.py                    # Main orchestration script
├── requirements.txt           # Python dependencies
├── .env                       # OpenAI API key (OPENAI_KEY=xxx)
├── .gitignore                 # Excludes .env, output/, programs/
├── src/                       # Source modules
│   ├── dsl_parser.py         # DSL rule parsing & validation
│   ├── cobol_generator.py    # API-powered COBOL generation
│   ├── cobol_cst_parser.py   # Tree-sitter CST-based COBOL parsing
│   ├── rule_detector.py      # Rule violation detection
│   ├── graph_generator.py    # Graph database operations
│   └── report_generator.py   # Text report generation
├── rules/                     # Global DSL rule definitions
│   ├── nsf_rule.dsl          # NSF banking rule
│   └── dual_approval.dsl     # Dual approval rule
├── programs/                  # Program-specific directories
│   ├── banking/              # Banking system programs
│   │   ├── *.cbl             # COBOL programs
│   │   ├── *.dsl             # Program-specific DSL rules
│   │   └── rules/            # Local rules override
│   ├── insurance/            # Insurance system programs
│   │   ├── *.cbl             # COBOL programs
│   │   ├── *.dsl             # Program-specific DSL rules
│   │   └── rules/            # Local rules override
│   └── healthcare/           # Healthcare system programs
│       ├── *.cbl             # COBOL programs
│       ├── *.dsl             # Program-specific DSL rules
│       └── rules/            # Local rules override
└── output/                    # Generated outputs
    ├── graph.json            # Graph representation
    └── report.html           # Compliance report
```

## File Checklist

**Required Files** (create these based on the architecture):
```
✅ main.py                - Main orchestration script
✅ src/dsl_parser.py      - DSL rule parsing
✅ src/cobol_generator.py - COBOL code generation  
✅ src/cobol_cst_parser.py - Tree-sitter CST-based COBOL parsing
✅ src/rule_detector.py   - Rule violation detection
✅ src/graph_generator.py - Graph database operations
✅ src/report_generator.py - Text report generation
✅ rules/nsf_rule.dsl     - NSF banking rule definition
✅ rules/dual_approval.dsl - Dual approval rule definition
✅ requirements.txt       - Python dependencies (✅ exists)
✅ programs/banking/      - Banking system programs directory
✅ programs/insurance/    - Insurance system programs directory
✅ programs/healthcare/   - Healthcare system programs directory
```

**Current Status**: Only `requirements.txt` exists. Create the other files using the modular architecture described above.

## Success Checklist

**Once you create the implementation files:**
- ✅ Run `python main.py` successfully
- ✅ See violations detected from DSL rules  
- ✅ View graph data in `output/graph.json`
- ✅ Modify `rules/*.dsl` files and see changes
- ✅ Analyze COBOL files with `python main.py --analyze-file programs/banking/withdrawal.cbl`
- ✅ Process multiple programs with `python main.py --analyze-dir programs/banking/`

**Current Status**: This is a **template/blueprint**. You need to implement the actual code files based on the architecture described.

## Architecture Benefits

✅ **DSL-Driven**: Rules in YAML, not hardcoded  
✅ **Graph-Enabled**: Rich data representation with **complete code-to-rule mapping**  
✅ **AI-Powered**: OpenI-generated enterprise-grade COBOL with domain expertise
✅ **CST-Parsed**: Tree-sitter-based comprehensive COBOL parsing with hierarchical structure
✅ **Modular**: Independent components with API integration
✅ **Multi-Program**: Each program directory can have its own DSL rules
✅ **Rule Inheritance**: Local > Program-specific > Global rule precedence
✅ **Business-Friendly**: Non-technical users can modify rules
✅ **Comprehensive**: Every code element connected to applicable DSL rules
✅ **Intelligent**: Sophisticated violation detection that passes cursory review

---

**Time to first demo**: 5 minutes  
**Time to customize**: 1 hour  
**Time to close first deal**: 30 days (if you have the network)

Good luck! 🚀
